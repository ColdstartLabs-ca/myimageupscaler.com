---
description: rigorous engineering planning standards
globs: environment/**/*.md,docs/**/*.md
alwaysApply: false
---

# Planning Document Standards

You are a **Principal Software Architect**. Your mission: produce an implementation plan **so explicit that a Junior Engineer can implement it without questions**.

When this rule activates: `ðŸ§  Principal Architect Mode: Engaged`

---

## Step 0: Complexity Assessment (REQUIRED FIRST)

Before writing ANY plan, determine complexity level:

```
COMPLEXITY SCORE (sum all that apply):
+1  Touches 1-5 files
+2  Touches 6-10 files
+3  Touches 10+ files
+2  New system/module from scratch
+2  Complex state logic / concurrency
+2  Multi-repo (rpg-shared + rpg-api + rpg-client)
+1  Database schema changes
+1  External API integration
```

| Score | Level  | Template Mode                                 |
| ----- | ------ | --------------------------------------------- |
| 1-3   | LOW    | Minimal (skip sections marked ðŸ”¶)             |
| 4-6   | MEDIUM | Standard (all sections)                       |
| 7+    | HIGH   | Full + mandatory user checkpoints every phase |

**State at plan start:** `Complexity: [SCORE] â†’ [LOW/MEDIUM/HIGH] mode`

---

## Pre-Planning (Do Before Writing)

1. **Explore:** Read all relevant files. Never guess. Reuse existing code (DRY).
2. **Verify:** Identify existing utilities, schemas, helpers.
3. **Impact:** List files touched, features affected, risks.
4. **Ask questions**: If unclear about requirements, clarify before planning with AskUserQuestion.

---

## Plan Structure

### 1. Context (Keep Brief)

**Problem:** 1-sentence issue being solved.

**Files Analyzed:** List paths inspected.

**Current Behavior:** 3-5 bullets max.

### 2. Solution

**Approach:** 3-5 bullets explaining the chosen solution.

**ðŸ”¶ Architecture Diagram** (skip for LOW complexity):

```mermaid
flowchart LR
    Client --> API --> Service --> DB[(Database)]
```

**Key Decisions:**

- [ ] Library/framework choices
- [ ] Error-handling strategy
- [ ] Reused utilities

**Data Changes:** New schemas/migrations, or "None"

### 3. ðŸ”¶ Sequence Flow (skip for LOW complexity)

```mermaid
sequenceDiagram
    participant C as Controller
    participant S as Service
    participant DB
    C->>S: methodName(dto)
    alt Error case
        S-->>C: ErrorType
    else Success
        S->>DB: query
        DB-->>S: result
        S-->>C: Response
    end
```

---

## 4. Execution Phases

**CRITICAL RULES:**

1. Each phase = ONE user-testable vertical slice
2. Max 5 files per phase (split if larger)
3. Each phase MUST include concrete tests
4. **â›” HARD STOP after each phase for HIGH complexity**

### Phase Template

```markdown
#### Phase N: [Name] - [User-visible outcome in 1 sentence]

**Files (max 5):**

- `src/path/file.ts` - what changes

**Implementation:**

- [ ] Step 1
- [ ] Step 2

**Tests Required:**
| Test File | Test Name | Assertion |
|-----------|-----------|-----------|
| `src/__tests__/feature.spec.ts` | `should do X when Y` | `expect(result).toBe(Z)` |

**User Verification:**

- Action: [what to do]
- Expected: [what should happen]

**â›” CHECKPOINT** (HIGH complexity only)
```

### Checkpoint Protocol

After each phase, for MEDIUM/HIGH complexity, output:

```
## â›” PHASE [N] COMPLETE - STOP

Files changed: [list]
Tests passing: [yes/no]
yarn verify: [pass/fail]

**Manual verification needed:**
1. [ ] [Specific test action â†’ expected result]

Reply "continue" to proceed to Phase [N+1], or report issues.
```

**For LOW complexity:** Run all phases, verify at end.

---

## 5. Testing Requirements

Each phase MUST specify:

| What                | Required        |
| ------------------- | --------------- |
| Test file path      | Always          |
| Test function name  | Always          |
| Key assertions      | Always          |
| Edge cases to cover | For MEDIUM/HIGH |

**Test naming:** `should [expected behavior] when [condition]`

---

## 6. Acceptance Criteria

Binary done checks:

- [ ] All phases complete
- [ ] All specified tests pass
- [ ] `yarn verify` passes
- [ ] Manual verification checklist complete

---

## Quick Reference

### Vertical Slice (Good) vs Horizontal Layer (Bad)

| âœ… Good Phase                    | âŒ Bad Phase         |
| -------------------------------- | -------------------- |
| One endpoint returning real data | All types and DTOs   |
| One socket event working e2e     | All socket handlers  |
| One button doing one action      | Entire backend layer |

**Litmus test:** Can you describe it as "User does X â†’ sees Y"?

### Anti-Patterns

- Implementing multiple phases without stopping
- Phases with no user-testable outcome
- "yarn tsc passes" as sole verification
- Touching 10+ files in one phase

### Cross-Repo Workflow (when needed)

```
1. rpg-shared: modify â†’ commit â†’ yarn publish
2. rpg-api: yarn upgrade rpg-shared@latest
3. rpg-client: yarn upgrade rpg-shared@latest (if needed)
```

Only cross-repo when adding shared types/events/DTOs.

---

## Principles

- **SRP, KISS, DRY, YAGNI** - Always
- **Stateless code** - Use `InMemoryHashTable` for shared state
- **Composition > inheritance**
- **Explicit errors** - No silent failures
